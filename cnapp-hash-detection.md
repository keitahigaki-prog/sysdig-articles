# セキュリティ製品は"設計思想"で使え
〜Hash検知が漏れた事象から考えるCNAPP運用のベストプラクティス〜

## はじめに

セキュリティ製品を導入したとき、よく聞く言葉があります。

> 「とりあえず有効化しました」
>
> 「エラーは出ていません」
>
> 「検知は上がっています」

でも、これは安心材料ではありません。

セキュリティ製品は**"動いていること"がゴールではない**。
**設計思想に沿って使えているかどうか**がすべてです。

この記事では、実際に起きたマルウェア検知の事象をもとに、

- Hash検知の限界
- データ品質問題の本質
- なぜベストプラクティスが重要なのか

を技術的に整理します。

---

## 実例：Hash検知のみ有効にしたら検知されなかった

ある検証で、Malware Detectionポリシーを以下の構成にしました。

| 設定項目 | 状態 |
|---|---|
| Malware Control | 有効 |
| Use Hashes | 有効 |
| Use YARA | **無効** |

テストとして EICAR（`elf_eicar`）を実行。

**結果：検知されない**

デバッグログには、以下が出力されていました。

```
Hash 'e1faac29ddf23aca2e8065309e76d252e6...' not matching in DB
```

---

## 何が起きていたのか？

整理すると、以下はすべて**正常**でした。

- エージェント
- Runtimeエンジン
- イベント取得
- ポリシー設定

にもかかわらず、

> **バックエンドのハッシュDBに想定ハッシュが存在していなかった**

という状態でした。

これは：

- エンジン障害ではない
- 改ざんでもない
- 配布破損でもない

**検知データの内容品質問題**です。

---

## Hash検知の仕組みを正しく理解する

Hash型マルウェア検知は構造上シンプルです。

```python
file_hash = sha256(file)
if file_hash in malicious_hash_db:
    detect()
```

つまり、

> **DBに存在するものしか検知できない**

という性質を持ちます。

これは製品の欠陥ではなく、**シグネチャ型検知の本質的制約**です。

### ではなぜ検知されなかったのか？

原因は構造的に以下のいずれかです。

1. DB登録漏れ
2. データ同期不備
3. ローテーション処理ミス
4. テナント反映遅延
5. Canary配布段階差

いずれにせよ、これは **SaaSバックエンドの品質管理プロセス** に属する問題です。

---

## ここでよく出る誤解

> 「署名を付ければ防げるのでは？」

これは**次元が違います**。

### 署名／SHA256で保証できること

署名が保証するのは：

- **配布物が改ざんされていないこと**

今回の問題は：

- **DB自体の中身が不完全だった**

仮に不完全なDBに正しい署名が付いても、ハッシュは一致します。
**内容の妥当性は保証されません。**

---

## 検知モデルの全体像を理解する

CNAPP / Runtime製品は通常、複数レイヤーで設計されています。

```
1. Hash検知       ← 既知マルウェアのシグネチャ照合
2. YARA検知       ← パターンマッチング
3. Runtime挙動検知 ← Falcoによる動的検知
4. ポリシー相関    ← 上記を統合した判断
```

設計思想は：

> **Defense in Depth（多層防御）**

Hashのみ有効化する構成は、**単一レイヤー依存**となり、思想から逸脱します。

---

## ベストプラクティスの意味

ベストプラクティスは、以下を前提に設計されています。

- スケール前提
- マルチテナント前提
- インシデント対応前提
- **過去事故の再発防止前提**

Hash + YARA + Runtime併用は "推奨" ではなく、

> **想定事故を前提とした設計**

です。

---

## 今回の件から見える教訓

### 1. 単一検知方式依存は危険

Hashが漏れたら終わり、という構成は危険。

### 2. データ品質はベンダー責任領域

顧客側での完全独立検証は原理的に困難。

### 3. 透明性と品質は別問題

ハッシュを公開しても、内容品質は保証できない。

---

## スケール視点で見るともっと怖い

小規模環境では気づきにくい。しかし**20,000台規模**になると：

- DBローテーションのタイミング差
- キャッシュ不整合
- 部分反映

が現実問題になります。

設計思想を無視すると、**スケールで破綻する**。

---

## インシデント対応時に何が起きるか？

設計通りに入れていないと：

- 相関不能
- 証跡不足
- 原因特定困難
- 責任分界曖昧

「検知していました」では守れません。

---

## ではどうすればよいか？

### ✅ 単一検知方式に依存しない

Hash + YARA + Runtime を**併用**する。

### ✅ 検知モデルを理解する

静的検知とRuntime検知は別物。それぞれの役割を把握する。

### ✅ ベストプラクティスを"理由ごと"理解する

なぜ推奨されているのかを理解した上で運用する。

---

## 結論

セキュリティ製品は裏切りません。

裏切るのは：

- 「とりあえず有効化」
- 思い込み
- 設計思想の無視

ベストプラクティスは縛りではありません。

> **未来の自分を守るための設計図です。**

---

## おわりに

「動いている」は合格ではない。

**「設計思想に沿っている」が合格です。**

今回のHash検知漏れは、

- 製品が壊れた話ではなく
- **設計と品質の話**

でした。

セキュリティ製品は**思想で使うもの**です。
